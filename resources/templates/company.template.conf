input {
    jdbc {
        jdbc_driver_library => "${JDBC_PATH}"
        jdbc_driver_class => "Java::oracle.jdbc.driver.OracleDriver"
        jdbc_connection_string => "jdbc:oracle:thin:@//${ORACLE_HOST:db-oracle:6565}/${ORACLE_DB:elephantsrv.aibees.net}"
        jdbc_user => "${ORACLE_USER:admin}"
        jdbc_password => "${ORACLE_PASSWORD:admin}"
        statement => "SELECT * FROM FN_COMPANY_V3_LIMITED(:sql_last_value, ${SQL_MAX_VALUE_COMPANY_V1_${INDEX}}, ${SQL_LIMITED_COMPANY})" 
        use_column_value => true
        tracking_column => "seq_number"
        tracking_column_type => "numeric"
        schedule => "*/1 * * * * *"
        last_run_metadata_path => "/etc/logstash/conf.d/jdbc/company_v1_${INDEX}_seq"
    }
}

filter {
    ruby {
        code => '
            def remove_empty_values(hash_or_array)
                if hash_or_array.is_a?(Hash)
                    hash_or_array.each do |key, value|
                        if value.is_a?(Hash) || value.is_a?(Array)
                            remove_empty_values(value)
                            if value.empty?
                                hash_or_array.delete(key)
                            end
                        end
                    end
                elsif hash_or_array.is_a?(Array)
                    hash_or_array.reject! do |item|
                        if item.is_a?(Hash) || item.is_a?(Array)
                            remove_empty_values(item)
                            item.empty?
                        else
                            false
                        end
                    end
                end
                hash_or_array
            end

            fields = ["summary", "link", "contact", "analytics", "financial", "retail", "location", "technologies", "industries_source", "keywords", "hashtags", "languages", "sub_organizations", "naics", "sic", "embedding"]
            fields.each do |field|
                if event.get(field)
                    begin
                        parsed = JSON.parse(event.get(field))
                        cleaned = remove_empty_values(parsed)
                         if cleaned.empty?
                            event.remove(field)
                         else
                           event.set(field, cleaned)
                         end
                    rescue JSON::ParserError => e
                        logger.warn("JSON parsing failed for field #{field}: #{e.message}")
                    end
                else
                    event.remove(field)
                end
            end
        '
    }

    ruby {
        code => "

            metrics = event.get('[analytics][linkedin][metrics]')
            if metrics
              metrics.each do |metric|
                if metric['departments']
                  metric['departments'].each do |department|
                    department.delete('month_count')
                  end
                end
              end
              event.set('[analytics][linkedin][metrics]', metrics)
            end

            if event.get('[location][headquarter]')
                headquarter = event.get('[location][headquarter]')
                if headquarter['position'] && headquarter['position']['lng']
                    headquarter['position']['lon'] = headquarter['position'].delete('lng')
                    event.set('[location][headquarter]', headquarter)
                end
            end
            if event.get('[location][locations]')
                locations = event.get('[location][locations]')
                locations.each_index do |i|
                    if locations[i]['position']
                        if locations[i]['position']['lng']
                            locations[i]['position']['lon'] = locations[i]['position'].delete('lng')
                        end
                    end
                end
                event.set('[location][locations]', locations)
            end
        "
    }

    mutate {
        copy => { "id" => "[@metadata][_id]" }
        remove_field => [
            "created", "modified", "version", "seq_number", "es_seq_number",
            "sent_to_cmp", "sent_to_mtr", "sent_to_cb", "sent_to_ps", "employee_count", "person_offset",
            "metadata_name", "metadata_staff_count", "metadata_link_domain", "metadata_link_linkedin", "metadata_link_crunchbase",
            "@version", "@timestamp"
        ]
    }
}

output {
    elasticsearch {
        hosts => ["${ELASTIC_HOSTS:https://db-elastic:9200}"]
        user => "${ELASTIC_USER:elastic}"
        password => "${ELASTIC_PASSWORD:elastic}"
        index => "${ELASTIC_COMPANY_INDEX:company_new}"
        ssl => true
        ssl_certificate_verification => false
        doc_as_upsert => true
        action => "update"
        document_id => "%{[@metadata][_id]}"
    }
}

