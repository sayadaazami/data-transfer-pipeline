input {
    jdbc {
        jdbc_driver_library => "${JDBC_PATH}"
        jdbc_driver_class => "Java::oracle.jdbc.driver.OracleDriver"
        jdbc_connection_string => "jdbc:oracle:thin:@//${ORACLE_HOST:db-oracle:6565}/${ORACLE_DB:elephantsrv.aibees.net}"
        jdbc_user => "${ORACLE_USER:admin}"
        jdbc_password => "${ORACLE_PASSWORD:admin}"
        statement => "SELECT * FROM FN_PERSON_V3_LIMITED(:sql_last_value, ${SQL_MAX_VALUE_PERSON_V1_${INDEX}}, ${SQL_LIMITED_PERSON})" 
        use_column_value => true
        tracking_column => "seq_number"
        tracking_column_type => "numeric"
        schedule => "*/1 * * * * *"
        last_run_metadata_path => "/etc/logstash/conf.d/jdbc/person_v1_${INDEX}_seq"
    }
}

filter {
    ruby {
        code => '
            def remove_empty_values(hash_or_array)
                if hash_or_array.is_a?(Hash)
                    hash_or_array.each do |key, value|
                        if value.is_a?(Hash) || value.is_a?(Array)
                            remove_empty_values(value)
                            if value.empty?
                                hash_or_array.delete(key)
                            end
                        end
                    end
                elsif hash_or_array.is_a?(Array)
                    hash_or_array.reject! do |item|
                        if item.is_a?(Hash) || item.is_a?(Array)
                            remove_empty_values(item)
                            item.empty?
                        else
                            false
                        end
                    end
                end
                hash_or_array
            end
            company = {}
            concrete_fields = ["id", "urn"]
            json_fields = ["summary", "link", "contact", "analytics", "financial", "retail", "location", "technologies", "industries_source", "keywords", "hashtags", "languages", "sub_organizations", "naics", "sic"]
            json_fields.each do |field|
                company_field = "company_" + field
                if event.get(company_field)
                    begin
                        parsed = JSON.parse(event.get(company_field))
                        cleaned = remove_empty_values(parsed)
                        if cleaned.empty?
                           event.remove(company_field)
                        else
                          event.set(company_field, cleaned)
                        end
                    rescue JSON::ParserError => e
                        logger.warn("JSON parsing failed for field #{company_field}: #{e.message}")
                    end
                else
                    event.remove(company_field)
                end
            end

        
            # calculate work_experiences based on position_groups
            work_experience = {
                "company" => { "current" => [], "past" => [], "latest" => nil },
                "title" => { "current" => [], "past" => [] }
            }
            
            position_groups = event.get("position_groups")
            if position_groups.is_a?(Array)
                position_groups_with_dates = []
                
                position_groups.each do |pg|
                    is_current = pg["current"] == true
                    company = (pg["company"] || {})["id"] || (pg["company"] || {})["name"]
                    profile_positions = Array(pg["profile_positions"])
                    date_start = (pg["date"] || {})["start"]
                    
                    # Add company
                    if company && !company.to_s.strip.empty?
                        list = is_current ? work_experience["company"]["current"] : work_experience["company"]["past"]
                        list << company.to_s unless list.include?(company.to_s)
                        position_groups_with_dates << { "company" => company.to_s, "date_start" => date_start } if date_start
                    end
                    
                    # Add titles
                    profile_positions.each do |pp|
                        title = pp["title"]
                        if title && !title.to_s.strip.empty?
                            list = is_current ? work_experience["title"]["current"] : work_experience["title"]["past"]
                            list << title.to_s unless list.include?(title.to_s)
                        end
                    end
                end
                
                # Find latest company
                if !position_groups_with_dates.empty?
                    latest = position_groups_with_dates.max_by do |pg|
                        begin
                            Date.parse(pg["date_start"].to_s)
                        rescue
                            Date.new(1900, 1, 1)
                        end
                    end
                    work_experience["company"]["latest"] = latest["company"] if latest
                end
                
                event.set("work_experience", work_experience) unless work_experience["company"]["current"].empty? && work_experience["company"]["past"].empty? && work_experience["company"]["latest"].nil? && work_experience["title"]["current"].empty? && work_experience["title"]["past"].empty?
            end

            company_to_add = {
                "id" => event.get("company_id"),
                "urn" => event.get("company_urn"),
                "summary" => event.get("company_summary"),
                "link" => event.get("company_link"),
                "contact" => event.get("company_contact"),
                "analytics" => event.get("company_analytics"),
                "financial" => event.get("company_financial"),
                "retail" => event.get("company_retail"),
                "location" => event.get("company_location"),
                "technologies" => event.get("company_technologies"),
                "industries_source" => event.get("company_industries_source"),
                "keywords" => event.get("company_keywords"),
                "hashtags" => event.get("company_hashtags"),
                "languages" => event.get("company_languages"),
                "sub_organizations" => event.get("company_sub_organizations"),
                "naics" => event.get("company_naics"),
                "sic" => event.get("company_sic"),
                "sub_organizations" => event.get("company_sub_organizations"),
            };
            company_to_add.each do |key, value|
                if !value.nil?
                    company[key] = value
                end
            end
            if !company.empty?
                event.set("company", company)
            else
                event.set("company", nil)
            end
            json_fields.each do |field|
                event.remove("company_" + field)
            end
        '
    }

    ruby {
        code => '
            def remove_empty_values(hash_or_array)
                if hash_or_array.is_a?(Hash)
                    hash_or_array.each do |key, value|
                        if value.is_a?(Hash) || value.is_a?(Array)
                            remove_empty_values(value)
                            if value.empty?
                                hash_or_array.delete(key)
                            end
                        end
                    end
                elsif hash_or_array.is_a?(Array)
                    hash_or_array.reject! do |item|
                        if item.is_a?(Hash) || item.is_a?(Array)
                            remove_empty_values(item)
                            item.empty?
                        else
                            false
                        end
                    end
                end
                hash_or_array
            end

            fields = ["profile", "contact", "link", "location", "causes", "treasury_media", "languages", "education", "patents", "awards", "certifications", "organizations", "projects", "publications", "courses", "test_scores", "position_groups", "volunteer_experiences", "skills", "member_badges", "statistics", "department", "flat_educations", "hash"]
            fields.each do |field|
                if event.get(field)
                    begin
                        parsed = JSON.parse(event.get(field))
                        cleaned = remove_empty_values(parsed)
                        if cleaned.empty?
                           event.remove(field)
                        else
                          event.set(field, cleaned)
                        end
                    rescue JSON::ParserError => e
                        logger.warn("JSON parsing failed for field #{field}: #{e.message}")
                    end
                else
                    event.remove(field)
                end
            end
        '
    }

    mutate {
        copy => { "id" => "[@metadata][_id]" }
        remove_field => [
            "company_id", "company_urn",
            "created", "modified", "version", "seq_number", "es_seq_number",
            "sent_to_li", "sent_to_dp", "sent_to_rd",
            "metadata_headline", "metadata_title",
            "@version", "@timestamp"
        ]
    }
}

output {
    elasticsearch {
        hosts => ["${ELASTIC_HOSTS:https://db-elastic:9200}"]
        user => "${ELASTIC_USER:elastic}"
        password => "${ELASTIC_PASSWORD:elastic}"
        index => "${ELASTIC_PERSON_INDEX:person_new}"
        ssl => true
        ssl_certificate_verification => false
        doc_as_upsert => true
        action => "update"
        document_id => "%{[@metadata][_id]}"
    }
}

