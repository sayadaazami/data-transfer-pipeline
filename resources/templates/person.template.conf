input {
    jdbc {
        jdbc_driver_library => "${JDBC_PATH}"
        jdbc_driver_class => "Java::oracle.jdbc.driver.OracleDriver"
        jdbc_connection_string => "jdbc:oracle:thin:@//${ORACLE_HOST}/${ORACLE_DB}"
        jdbc_user => "${ORACLE_USER}"
        jdbc_password => "${ORACLE_PASSWORD}"
        statement => "SELECT * FROM FN_PERSON_V3_LIMITED(:sql_last_value, ${SQL_MAX_VALUE_PERSON_V1_${INDEX}}, ${SQL_LIMITED_PERSON})" 
        use_column_value => true
        tracking_column => "seq_number"
        tracking_column_type => "numeric"
        schedule => "*/1 * * * * *"
        last_run_metadata_path => "/etc/logstash/conf.d/jdbc/person_v1_${INDEX}_seq"
    }
}

filter {
    ruby {
        code => '
            def remove_empty_values(hash_or_array)
                if hash_or_array.is_a?(Hash)
                    hash_or_array.each do |key, value|
                        if value.is_a?(Hash) || value.is_a?(Array)
                            remove_empty_values(value)
                            if value.empty?
                                hash_or_array.delete(key)
                            end
                        end
                    end
                elsif hash_or_array.is_a?(Array)
                    hash_or_array.reject! do |item|
                        if item.is_a?(Hash) || item.is_a?(Array)
                            remove_empty_values(item)
                            item.empty?
                        else
                            false
                        end
                    end
                end
                hash_or_array
            end
            company = {}
            concrete_fields = ["id", "urn"]
            json_fields = ["summary", "link", "contact", "analytics", "financial", "retail", "location", "technologies", "industries_source", "keywords", "hashtags", "languages", "sub_organizations", "naics", "sic"]
            json_fields.each do |field|
                company_field = "company_" + field
                if event.get(company_field)
                    begin
                        parsed = JSON.parse(event.get(company_field))
                        cleaned = remove_empty_values(parsed)
                        if cleaned.empty?
                           event.remove(company_field)
                        else
                          event.set(company_field, cleaned)
                        end
                    rescue JSON::ParserError => e
                        logger.warn("JSON parsing failed for field #{company_field}: #{e.message}")
                    end
                else
                    event.remove(company_field)
                end
            end

            company_to_add = {
                "id" => event.get("company_id"),
                "urn" => event.get("company_urn"),
                "summary" => event.get("company_summary"),
                "link" => event.get("company_link"),
                "contact" => event.get("company_contact"),
                "analytics" => event.get("company_analytics"),
                "financial" => event.get("company_financial"),
                "retail" => event.get("company_retail"),
                "location" => event.get("company_location"),
                "technologies" => event.get("company_technologies"),
                "industries_source" => event.get("company_industries_source"),
                "keywords" => event.get("company_keywords"),
                "hashtags" => event.get("company_hashtags"),
                "languages" => event.get("company_languages"),
                "sub_organizations" => event.get("company_sub_organizations"),
                "naics" => event.get("company_naics"),
                "sic" => event.get("company_sic")
            };
            company_to_add.each do |key, value|
                if !value.nil?
                    company[key] = value
                end
            end
            if !company.empty?
                event.set("company", company)
            end
            json_fields.each do |field|
                event.remove("company_" + field)
            end


            # calculate work_experience
            work_experience = nil
            position_groups_raw = event.get("position_groups")
            
            if position_groups_raw
                begin
                    # Parse if its a JSON string, otherwise use as-is
                    position_groups = position_groups_raw.is_a?(String) ? JSON.parse(position_groups_raw) : position_groups_raw

                    if position_groups.is_a?(Array) && !position_groups.empty?
                        # Flatten positions: create a map indexed by position index
                        flat_positions = {}
                        index = 0

                        position_groups.each do |position_group|
                            next unless position_group.is_a?(Hash)
                            profile_positions = position_group["profile_positions"] || []

                            profile_positions.each do |profile_position|
                                next unless profile_position.is_a?(Hash)

                                # Get company - prefer from position_group, fallback to profile_position
                                company_obj = position_group["company"] || profile_position["company"]

                                # Extract company ID and name, store both as array items
                                company_items = []
                                if company_obj.is_a?(Hash)
                                    id = company_obj["id"]
                                    name = company_obj["name"]
                                    company_items << id if id && !id.to_s.strip.empty?
                                    company_items << name if name && !name.to_s.strip.empty?
                                elsif company_obj.is_a?(String) && !company_obj.strip.empty?
                                    company_items << company_obj
                                end
                                company_items = nil if company_items.empty?

                                # Get title
                                title = profile_position["title"]
                                title = title.strip if title.is_a?(String)

                                # Get is_current
                                is_current = profile_position["current"] == true

                                # Store flat position
                                flat_positions[index.to_s] = {
                                    "company" => company_items,
                                    "title" => title,
                                    "is_current" => is_current
                                }
                                index += 1
                            end
                        end

                        if !flat_positions.empty?
                            # Get company history
                            current_companies = []
                            past_companies = []
                            latest_company = nil
                            earliest_current_index = nil

                            flat_positions.each do |idx_str, flat_pos|
                                company = flat_pos["company"]
                                is_current = flat_pos["is_current"]

                                # Add each non-nil company id/name as its own array item
                                next if company.nil?
                                if is_current
                                    company.each do |item|
                                        next if item.to_s.strip.empty?
                                        current_companies << item unless current_companies.include?(item)
                                        idx = idx_str.to_i
                                        if earliest_current_index.nil? || idx < earliest_current_index
                                            earliest_current_index = idx
                                            latest_company = item
                                        end
                                    end
                                else
                                    company.each do |item|
                                        next if item.to_s.strip.empty?
                                        past_companies << item unless past_companies.include?(item)
                                    end
                                end
                            end

                            # Remove current companies from past
                            past_companies = past_companies - current_companies

                            company_history = {
                                "latest" => latest_company,
                                "current" => current_companies.empty? ? nil : current_companies.uniq,
                                "past" => past_companies.empty? ? nil : past_companies.uniq
                            }

                            # Remove nil values
                            company_history.delete_if { |k, v| v.nil? }

                            # Get title history
                            current_titles = []
                            past_titles = []

                            flat_positions.each do |idx_str, flat_pos|
                                title = flat_pos["title"]
                                is_current = flat_pos["is_current"]

                                if title && !title.to_s.strip.empty?
                                    title_str = title.to_s
                                    if is_current
                                        current_titles << title_str unless current_titles.include?(title_str)
                                    else
                                        past_titles << title_str unless past_titles.include?(title_str)
                                    end
                                end
                            end

                            title_history = {
                                "current" => current_titles.empty? ? nil : current_titles.uniq.sort,
                                "past" => past_titles.empty? ? nil : past_titles.uniq.sort
                            }

                            # Remove nil values
                            title_history.delete_if { |k, v| v.nil? }

                            # Build work_experience object
                            work_experience = {
                                "company" => company_history.empty? ? nil : company_history,
                                "title" => title_history.empty? ? nil : title_history
                            }

                            # Remove nil values
                            work_experience.delete_if { |k, v| v.nil? }
                            work_experience = nil if work_experience.empty?
                        end
                    end
                rescue => e
                    logger.warn("Error calculating work_experience: #{e.message}")
                    work_experience = nil
                end
            end

            event.set("work_experience", work_experience)
        '
    }

    ruby {
        code => '
            def remove_empty_values(hash_or_array)
                if hash_or_array.is_a?(Hash)
                    hash_or_array.each do |key, value|
                        if value.is_a?(Hash) || value.is_a?(Array)
                            remove_empty_values(value)
                            if value.empty?
                                hash_or_array.delete(key)
                            end
                        end
                    end
                elsif hash_or_array.is_a?(Array)
                    hash_or_array.reject! do |item|
                        if item.is_a?(Hash) || item.is_a?(Array)
                            remove_empty_values(item)
                            item.empty?
                        else
                            false
                        end
                    end
                end
                hash_or_array
            end

            fields = ["profile", "contact", "link", "location", "causes", "treasury_media", "languages", "education", "patents", "awards", "certifications", "organizations", "projects", "publications", "courses", "test_scores", "position_groups", "volunteer_experiences", "skills", "member_badges", "statistics", "department", "flat_educations", "hash"]
            fields.each do |field|
                if event.get(field)
                    begin
                        parsed = JSON.parse(event.get(field))
                        cleaned = remove_empty_values(parsed)
                        if cleaned.empty?
                           event.remove(field)
                        else
                          event.set(field, cleaned)
                        end
                    rescue JSON::ParserError => e
                        logger.warn("JSON parsing failed for field #{field}: #{e.message}")
                    end
                else
                    event.remove(field)
                end
            end
        '
    }

    mutate {
        copy => { "id" => "[@metadata][_id]" }
        remove_field => [
            "company_id", "company_urn",
            "created", "modified", "version", "seq_number", "es_seq_number",
            "sent_to_li", "sent_to_dp", "sent_to_rd",
            "metadata_headline", "metadata_title",
            "flat_work_experiences", "status",
            "[work_experience][title][latest]",
            "[company][embedding]", "[company][link][sanitized]", "[company][status]",
            "@version", "@timestamp"
        ]
    }
}

output {
    elasticsearch {
        hosts => ["${ELASTIC_HOST}"]
        user => "${ELASTIC_USER}"
        password => "${ELASTIC_PASSWORD}"
        index => "${ELASTIC_PERSON_INDEX:person_new}"
        ssl => true
        ssl_certificate_verification => false
        doc_as_upsert => true
        action => "update"
        document_id => "%{[@metadata][_id]}"
    }
}

